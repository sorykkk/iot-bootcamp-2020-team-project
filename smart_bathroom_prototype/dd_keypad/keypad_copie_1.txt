#include "keypad_lcd.h"

//--------------------------------------------------------------------------------------------------------------
LiquidCrystal lcd(rs, en, d4, d5, d6, d7);

byte grad[8] =
{
	B00110,
	B01001,
	B01001,
	B00110,
	B00000,
	B00000,
	B00000
};

unsigned int CountNumberOfDigits(unsigned int n)//returneaza numarul de cifre introdus de pe keypad
{
	int count = 0;
	while(n != 0)
	{
		n /= 10;
		count++;
	}

	return count;
}

bool LengthOfDistance(unsigned int num)
{
	if(CountNumberOfDigits(num) > DIST_LENGTH_LIMIT || (num > DIST_MAX_LIMIT) || (num <= DIST_MIN_LIMIT) || (num > initial_distance))
		return false;

	else return true;
}

bool LengthOfTemperature(unsigned int num)
{
	if(CountNumberOfDigits(num) > TEMP_LENGTH_LIMIT || (num > TEMP_MAX_LIMIT) || (num <= TEMP_MIN_LIMIT))
		return false;

	else return true;
}

void InitialDisplay(char nr_of_display)
{
	lcd.setCursor(0, 0);
	if(nr_of_display == 0)
	{
		setted_distance = 0;
		lcd.print("GIVE DIST. (cm):");
	}
	if(nr_of_display == 1)
	{
		setted_temp = 0;
		lcd.print("GIVE TEMP. ("); lcd.write((byte)0); lcd.write('C'); lcd.print("):");
	}
	lcd.setCursor(0, 1);//cursorul se muta by default pe a 2 linie a 0 col
}

void InitLCDStartPhase(void)//Se initializeaza lcd, se printeaza prima linie, si cursorul se muta pe a 2 pt tapare
{
	lcd.begin(16, 2);
	lcd.createChar(0, grad);
	InitialDisplay(0);//se afiseaza de la inceput, pt ca nu a fost apasat nici un buton
}

void PrintSettedKeypadValue(char nr_of_display)//se printeaza valoarea setata
{
	if(nr_of_display == 0)
	{
		lcd.setCursor(0, 0);
		lcd.print("SETTED DISTANCE:");
		lcd.setCursor(0, 1);
		lcd.print(setted_distance);
		lcd.setCursor(CountNumberOfDigits(setted_distance)+1, 1);//se numara din cate cifre este compus numarul pt a se lua un spatiu rezerva
		lcd.print("cm");//pentru a se printa unitatea de masura
	}

	if(nr_of_display == 1)
	{
		lcd.setCursor(0, 0);
		lcd.print("SETTED TEMP.:");
		lcd.setCursor(0, 1);
		lcd.print(setted_temp);
		lcd.setCursor(CountNumberOfDigits(setted_temp)+1, 1);//se numara din cate cifre este compus numarul pt a se lua un spatiu rezerva
		lcd.write((byte)0); lcd.print("C");
	}
}

void WarningMessage(void)
{
	lcd.print("*IVALID VALUE*");
	delay(2000);
}

void PrintGeneralDistanceInfo(unsigned int num)//se efectueaza printarea informatiei dupa conditiile din LengthOfValue()
{
	if(LengthOfDistance(num))// se verifica daca satisface cerintele inputului
	{					  //nu va permite setarea/afisarea distantei ca 0, dupa apasarea dubla pe '#'
		if(num)
		{
			lcd.clear();
			PrintSettedKeypadValue(0);//se afiseaza valoarea setata
										//daca dinstance e 0 nu se va efectua nimic, adica nu se va efectua functia WarningMessage();
			delay(2000);
			lcd.clear();
			InitialDisplay(1);
		}
	}

	else
	{
		lcd.clear();
		WarningMessage();
		InitialDisplay(0);
	}
}

void PrintGeneralTemperatureInfo(unsigned int num)//se efectueaza printarea informatiei dupa conditiile din LengthOfValue()
{
	if(LengthOfTemperature(num))// se verifica daca satisface cerintele inputului
	{					  //nu va permite setarea/afisarea distantei ca 0, dupa apasarea dubla pe '#'
		if(num)
		{
			lcd.clear();
			PrintSettedKeypadValue(1);
			delay(2000);
			lcd.clear();
		}
	}

	else
	{
		/**/input_permision = true;
		lcd.clear();
		WarningMessage();
		InitialDisplay(1);
	}
}

//--------------------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------------------
char hex_map[ROWS][COLS] =
{
  {'1', '2', '3'},
  {'4', '5', '6'},
  {'7', '8', '9'},
  {'*', '0', '#'}
};

byte pin_rows[ROWS] = {26, 24, 22, 2};
byte pin_cols[COLS] = {3, 4, 5, 44};

Keypad mkeypad = Keypad(makeKeymap(hex_map), pin_rows, pin_cols, ROWS, COLS);

unsigned int GetKeypadValue(unsigned int number, char nr_of_switch)
{
	char key = mkeypad.getKey();

	if(key == NO_KEY)
	   return number;

	while(key != '#')
	{
//	  switch (key)
//	  {
//		 case NO_KEY: break;
//
//		 case '0'...'9':
//					   lcd.print(key);
//					   number = number * 10 + (key - '0');
//					   break;
//
//		 case '*':
//			 	 lcd.clear();
//				 number = 0;
//				 InitialDisplay(0);
//				 break;
//	  }
		if(nr_of_switch == 0)//for distance
			{
				switch (key)
				  {
					 case NO_KEY: break;

					 case '0'...'9':
								   lcd.print(key);
								   number = number * 10 + (key - '0');
								   break;

					 case '*':
							 lcd.clear();
							 number = 0;
							 InitialDisplay(0);
							 break;
				  }
			}

			if(nr_of_switch == 1)//for temp
			{
				switch (key)
				  {
					 case NO_KEY: break;

					 case '0'... '9':
								   lcd.print(key);
								   number = number * 10 + (key - '0');
								   break;

					 case '*':
						 if(number == 0)
						 {
							 lcd.clear();
							 /**/input_permision = false;//la apasarea dubla a '*' se duce la InitialDisplay(0);// afecteaza while(input_permision) cand nu intra in if();
							 /**/program_state = false; // face ca dupa *incorect value* la temp, sa lucreze dublu '*' si sa intoarca la "give dist."
							 InitialDisplay(0);
							 /**/return number;//greu se muta din give temp in give dist
							 break;
						 }

						 else
						 {
							 lcd.clear();
							 number = 0;
							 InitialDisplay(1);
							 break;
						 }

				  }
			}
	  key = mkeypad.getKey();
	}

	return number;
}

//unsigned int GetTemperatureValue(unsigned int number)
//{
//	char key = mkeypad.getKey();
//
//	if(key == NO_KEY)
//	   return number;
//
//	while(key != '#')
//	{
//	  switch (key)
//	  {
//		 case NO_KEY: break;
//
//		 case '0'... '9':
//					   lcd.print(key);
//					   number = number * 10 + (key - '0');
//					   break;
//
//		 case '*':
//			 if(number == 0)
//			 {
//				 lcd.clear();
//				 /**/input_permision = false;//la apasarea dubla a '*' se duce la InitialDisplay(0);// afecteaza while(input_permision) cand nu intra in if();
//				 /**/program_state = false; // face ca dupa *incorect value* la temp, sa lucreze dublu '*' si sa intoarca la "give dist."
//				 InitialDisplay(0);
//				 /**/return number;//greu se muta din give temp in give dist
//				 break;
//			 }
//
//			 else
//			 {
//				 lcd.clear();
//				 number = 0;
//				 InitialDisplay(1);
//				 break;
//			 }
//
//	  }
//	  key = mkeypad.getKey();
//	}
//
//	return number;
//}
//--------------------------------------------------------------------------------------------------------------
